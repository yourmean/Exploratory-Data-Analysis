# Q1 ------------------------------------

### 함수f(x,y), amd 각 x,y로 미분한 함수
f = function(x) # 함수: f(x1,x2)
{
  f = ( 1 - x[1] )^2 + 100 * ( x[2] - x[1]^2 )^2
  return(f)
}


# 1차 미분
df = function(x)
{
  df1 = 2 * x[1] - 2 - 400 * x[1] * ( x[2] - x[1]^2 )
  df2 = 200 * ( x[2] - x[1]^2 )
  df = c(df1, df2)
  return(df)
}



### 1. 최대하강법을 이용한 최소값 구하기
Steepest.Desc = function(x0, lambda = 1, epsilon = 1e-5){
  xh = NULL; fh = NULL
  fx0 = f(x0); ni = 0
  for (i in 1:1e+5) # 반복수를 적당히 많이 부여함
  {
    xh = rbind(xh, x0); fh = c(fh, fx0); ni = ni+1 # 결과 저장
    if(i %% 1000 == 1){ # 1000번마다 프린트
      cat("iteration=", round(i,2))
      cat(" x0=", round(x0,2), " f(x0)=", round(f(x0),3), "\n")
    }
    d = df(x0) # 이동 방향 선택
    x = x0 - lambda * d; fx = f(x) # lambda = 1, 값 갱신
    if (fx0 == Inf) stop("x does not converge") # 값이 수렴하지 않을 경우 멈춤
    if (abs(fx - fx0) < epsilon) break # 반복 중 수렴조건을 만족하면 멈춤
    for (iters in 1:20) # 스텝반감법
    {
      x = x0 - d; fx = f(x)
      if (fx < fx0) break
      d = d / 2
    }
    x0 = x; fx0 = fx # 수렴조건을 만족하지 않으면 다음스텝 반복
  } # 반복 끝
}
Steepest.Desc(x0 = c(0, 3), lambda = 1)



### 2. 뉴튼-랩슨 알고리즘을 이용한 최소값 구하기

# 이차미분
df2 = function(x){
  df2 = matrix(c(2 - 400 * x[2] + 1200 * x[1]^2, - 400 * x[1], - 400 * x[1], 200), 2, 2)
  return(df2)
}

Newton.Raphson = function(x0, lambda = 1, epsilon = 1e-5, n = 100){
  xh = NULL; fh = NULL # 초기값 설정
  fx0 = f(x0); ni = 0
  for (i in 1:n)
  {
    xh = rbind(xh, c(x0)); fh = c(fh, fx0); ni = ni+1 # 결과 저장
    cat("iteration=", round(i,2)) # 결과 출력
    cat(" x0=", round(x0,2), " f(x0)=", round(f(x0),3), "\n")
    d = solve(df2(x0)) %*% df(x0) # 이동 방향 선택, solve() = 역함수 계산
    x = x0 - lambda * d; fx = f(x) # lambda = 1, 값 갱신
    if (abs(fx - fx0) < epsilon) break # 반복 중 수렴조건을 만족하면 멈춤
    x0 = x; fx0 = fx # 수렴조건을 만족하지 않으면 다음스텝 반복
  } # 반복 끝
}
Newton.Raphson(c(0, 3)) # 실행



# Q2 ------------------------------------

### 함수 지정
f = function(x){ # f(x) 를 구간 x<1, x>=1로 나누어 값 출력
  if(x >= 1){
    y = (x - 1)^{1/3}
  }else{
    y = -(1 - x)^{1/3}
  }
  return(y)
}


### 1. 이분법
Bisection = function(x0, x1, epsilon = 1e-5)
{
  fx0 = f(x0) # 초기값 부여
  fx1 = f(x1)
  if (fx0 * fx1 > 0) # 부호가 같으면 초기값을 잘못 지정한 것
    return("wrong initial values")
  N = 0
  cat("시작=", "(", x0, ",", x1, ")", "\n") # 초기값 결과 출력
  error = abs(x0-x1) # 에러 계산
  while (error > epsilon) # 반복 시작
  {
    N = N + 1
    x2 = (x0 + x1) / 2 # x값 갱신
    fx2 = f(x2) # y값 갱신
    error = abs(x2-1) # 갱신한 값에 대해 에러 계산
    cat("반복수=", N, " 근사적인 해=", x2, " 참값과의 차이=", error, "\n") # 결과 출력
    if (fx0 * fx2 == 0) break # 해를 정확히 찾은경우 멈춤
    if (fx0 * fx2 < 0) # 반복
    {
      x1 = x2; fx1 = fx2
    } else
    {
      x0 = x2; fx0 = fx2
    }
  } # 반복 끝
}
Bisection(-1, 3)

## 시작= ( -1 , 3 )
## 반복수= 1 근사적인 해= 1 참값과의 차이= 0


### 2. 뉴턴법
Newton = function(x0, epsilon = 1e-5, n = 100)
{
  # 그래프 그리기 위한 코드
  x = data.frame("x" = seq(-100, 200, length = 200), "y" = NA)
  for(i in 1:200) x[i,2] = f(x[i,1])
  plot(x[,1], x[,2], type = 'l', xlab = 'x', ylab = 'y'); abline(h = 0); abline(v = 0, col = "grey")
  points(x0, f(x0), pch = "0") # 이동하는 부분 그래프에 그리기
  #
  error = abs(x0-1)
  N = 0
  d = epsilon
  cat("시작=", x0, "\n") # 결과 출력
  while(error > epsilon){
    N = N + 1
    if (N > n){
      return("not converge after 100 iterations")
    }
    x1 = x0 - f(x0) * d / (f(x0 + d) - f(x0)) # 값 갱신
    if(x1 == Inf) break # 값이 수렴하지 않을 경우 멈춤
    error = abs(x1 - 1) # 오차 확인
    cat("반복수=", N, " 근사적인 해=", x1, " 참값과의 차이=", error, "\n")
    points(x1, f(x1), pch = as.character(N)) # 이동하는 부분 그래프에 그리기
    x0 = x1
  }
}
Newton(3)
## 시작= 3
## 반복수= 1 근사적인 해= -3.00001 참값과의 차이= 4.00001
## 반복수= 2 근사적인 해= 9.00001 참값과의 차이= 8.00001
## 반복수= 3 근사적인 해= -15.00003 참값과의 차이= 16.00003
## 반복수= 4 근사적인 해= 33.00005 참값과의 차이= 32.00005
## 반복수= 5 근사적인 해= -63.00011 참값과의 차이= 64.00011
## 반복수= 6 근사적인 해= 129.0002 참값과의 차이= 128.0002
## 반복수= 7 근사적인 해= -255.0004 참값과의 차이= 256.0004
## 반복수= 8 근사적인 해= 513.0009 참값과의 차이= 512.0009
## 반복수= 9 근사적인 해= -1023.002 참값과의 차이= 1024.002
## 반복수= 10 근사적인 해= 2049.003 참값과의 차이= 2048.003
## 반복수= 11 근사적인 해= -4095.007 참값과의 차이= 4096.007
## 반복수= 12 근사적인 해= 8193.013 참값과의 차이= 8192.013
## 반복수= 13 근사적인 해= -16383.02 참값과의 차이= 16384.02
## 반복수= 14 근사적인 해= 32769.02 참값과의 차이= 32768.02
## 반복수= 15 근사적인 해= -65534.97 참값과의 차이= 65535.97
## 반복수= 16 근사적인 해= 131072.8 참값과의 차이= 131071.8
## 반복수= 17 근사적인 해= -262142.9 참값과의 차이= 262143.9
## 반복수= 18 근사적인 해= 524292.2 참값과의 차이= 524291.2
## 반복수= 19 근사적인 해= -1048595 참값과의 차이= 1048596
## 반복수= 20 근사적인 해= 2097169 참값과의 차이= 2097168
## 반복수= 21 근사적인 해= -4193669 참값과의 차이= 4193670
## 반복수= 22 근사적인 해= 8387027 참값과의 차이= 8387026
## 반복수= 23 근사적인 해= -16775132 참값과의 차이= 16775133
## 반복수= 24 근사적인 해= 33542334 참값과의 차이= 33542333
## 반복수= 25 근사적인 해= -67051600 참값과의 차이= 67051601
## 반복수= 26 근사적인 해= 134271916 참값과의 차이= 134271915
## 반복수= 27 근사적인 해= -267889300 참값과의 차이= 267889301
## 반복수= 28 근사적인 해= 530748609 참값과의 차이= 530748608
## 반복수= 29 근사적인 해= -1051860233 참값과의 차이= 1051860234
## 반복수= 30 근사적인 해= 2142994587 참값과의 차이= 2142994586
## 반복수= 31 근사적인 해= -4157253721 참값과의 차이= 4157253722
## 반복수= 32 근사적인 해= 9986303673 참값과의 차이= 9986303672
## 반복수= 33 근사적인 해= -37368576826 참값과의 차이= 37368576827


# Q3 ------------------------------------

### 함수 정의
f = function(x) {3 * sqrt(x) / 2}


### 1. 직사각형법
Integral = function(a, b, n)
{
  integral = 0
  h = (b - a) / n
  for (i in 1:n)
    integral = integral + h * f(a + (i-1/2) * h) # 직사각형의 넓이
  return(integral)
}


### 2. 사다리꼴법
Trapezoid = function(a, b, n = 50)
{
  h = (b - a) / n
  integral = (f(a) + f(b)) / 2 # 사다리꼴의 넓이
  x = a
  n1 = n - 1
  for (i in 1:n1)
  {
    x = x + h
    integral = integral + f(x)
  }
  integral = integral * h
  return(integral)
}


### 3. 심슨 적분법
Simpson = function(a, b, n = 12)
{
  h = (b - a) / n
  integral = f(a) + f(b)
  x2 = a
  x3 = a + h
  even = 0
  odd = f(x3)
  h2 = 2 * h
  n1 = n / 2 - 1
  for (i in 1:n1)
  {
    x2 = x2 + h2
    x3 = x3 + h2
    even = even + f(x2)
    odd = odd + f(x3)
  }
  integral = (integral + 4 * odd + 2 * even) * h / 3
  return(integral)
}



# 결과
n = seq(2, 20, by = 2)
for(i in n){
  int = round(Integral(0, 1, n = i), 4)
  Tra = round(Trapezoid(0, 1, n = i), 4)
  sim = round(Simpson(0, 1, n = i), 4)
  cat("n =", i, '\n')
  cat("[적분값] ", "직사각형법:", int, " 사다리꼴법:", Tra, " 심슨법:", sim, '\n')
  cat("[참값과의 차이]", "직사각형법:", abs(1 - int), " 사다리꼴법:", abs(1 - Tra), " 심슨
법:", abs(1 - sim), '\n', '\n')
}


## n = 2
## [적분값] 직사각형법: 1.0245 사다리꼴법: 0.9053 심슨법: 4.9701
## [참값과의 차이] 직사각형법: 0.0245 사다리꼴법: 0.0947 심슨법: 3.9701
##
## n = 4
## [적분값] 직사각형법: 1.0095 사다리꼴법: 0.9649 심슨법: 0.9848
## [참값과의 차이] 직사각형법: 0.0095 사다리꼴법: 0.0351 심슨법: 0.0152
##
## n = 6
## [적분값] 직사각형법: 1.0053 사다리꼴법: 0.9805 심슨법: 0.9917
## [참값과의 차이] 직사각형법: 0.0053 사다리꼴법: 0.0195 심슨법: 0.0083
##
## n = 8
## [적분값] 직사각형법: 1.0035 사다리꼴법: 0.9872 심슨법: 0.9946
## [참값과의 차이] 직사각형법: 0.0035 사다리꼴법: 0.0128 심슨법: 0.0054
##
## n = 10
## [적분값] 직사각형법: 1.0026 사다리꼴법: 0.9908 심슨법: 0.9961
## [참값과의 차이] 직사각형법: 0.0026 사다리꼴법: 0.0092 심슨법: 0.0039
##
## n = 12
## [적분값] 직사각형법: 1.002 사다리꼴법: 0.9929 심슨법: 0.9971
## [참값과의 차이] 직사각형법: 0.002 사다리꼴법: 0.0071 심슨법: 0.0029
##
## n = 14
## [적분값] 직사각형법: 1.0016 사다리꼴법: 0.9944 심슨법: 0.9977
## [참값과의 차이] 직사각형법: 0.0016 사다리꼴법: 0.0056 심슨법: 0.0023
##
## n = 16
## [적분값] 직사각형법: 1.0013 사다리꼴법: 0.9954 심슨법: 0.9981
## [참값과의 차이] 직사각형법: 0.0013 사다리꼴법: 0.0046 심슨법: 0.0019
##
## n = 18
## [적분값] 직사각형법: 1.0011 사다리꼴법: 0.9961 심슨법: 0.9984
## [참값과의 차이] 직사각형법: 0.0011 사다리꼴법: 0.0039 심슨법: 0.0016
##
## n = 20
## [적분값] 직사각형법: 1.0009 사다리꼴법: 0.9967 심슨법: 0.9986
## [참값과의 차이] 직사각형법: 9e-04 사다리꼴법: 0.0033 심슨법: 0.0014
##