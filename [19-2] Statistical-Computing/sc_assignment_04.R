# Q1 ------------------------------------ 

# 승산합동법 함수에서 U[0,1] 따르는 난수 100개 생성
random_uni = function(n, seed){
  for(i in 1:(n-1)){
    seed[i+1] = ((16807*seed[i]) %% 2147483647)
  }
  return(seed/2147483647)
}
ran_seed = random_uni(n = 100, seed = 2020)

ran_seed
## [1] 9.406358e-07 1.580927e-02 7.063320e-01 3.227508e-01 4.732665e-01
## [6] 1.898196e-01 2.975564e-01 3.012475e-02 3.067281e-01 1.787398e-01
## [11] 7.964980e-02 6.741965e-01 2.210716e-01 5.499991e-01 8.356633e-01
## [16] 9.925028e-01 9.943905e-01 7.217558e-01 5.503361e-01 4.996145e-01
## [21] 2.131979e-02 3.216684e-01 2.808790e-01 7.328186e-01 4.817194e-01
## [26] 2.571188e-01 3.961307e-01 7.690793e-01 9.163038e-01 3.187008e-01
## [31] 4.050008e-01 8.480776e-01 6.400402e-01 1.550472e-01 8.783177e-01
## [36] 8.854069e-01 3.313678e-02 9.299071e-01 9.491816e-01 8.955188e-01
## [41] 9.841149e-01 1.854891e-02 7.515782e-01 7.740096e-01 7.787867e-01
## [46] 6.752100e-02 8.254836e-01 9.021306e-01 1.083997e-01 8.741329e-01
## [51] 5.510394e-01 3.194513e-01 1.816531e-02 3.043560e-01 3.118174e-01
## [56] 7.152582e-01 3.445448e-01 7.651137e-01 2.656988e-01 6.003653e-01
## [61] 3.399416e-01 3.992465e-01 1.362474e-01 9.097666e-01 4.465411e-01
## [66] 1.706628e-02 8.329037e-01 6.119046e-01 2.804477e-01 4.837849e-01
## [71] 9.731319e-01 4.283315e-01 9.671390e-01 7.052366e-01 9.112328e-01
## [76] 8.973526e-02 1.805664e-01 7.795067e-01 1.696471e-01 2.588096e-01
## [81] 8.131844e-01 1.909465e-01 2.380587e-01 5.275657e-02 6.797084e-01
## [86] 8.592061e-01 6.777041e-01 1.735189e-01 3.322369e-01 9.049156e-01
## [91] 9.158716e-01 5.365444e-02 7.700988e-01 5.080103e-02 8.128785e-01
## [96] 4.943671e-02 8.827514e-01 4.031565e-01 8.514917e-01 2.088993e-02



# (a) 1. 카이제곱 적합도 검정
k = 11
N = 100
range = seq(0, 1, length = k) # [0, 1]을 10등분
n = as.numeric(table(cut(ran_seed, range))) # 구간별로 난수의 갯수 세기
W = ((k-1)/N) * sum((n-(N/(k-1)))^2)
pchisq(W, df = k-2, lower.tail = FALSE) # p-value
U[0, 1]
ui
## [1] 0.1372824

# (a) 2. 콜모고로프-스미르노프 적합도 검정(by ks.test)
u = runif(100)
ks.test(ran_seed, u)
##
## Two-sample Kolmogorov-Smirnov test
##
## data: ran_seed and u
## D = 0.12, p-value = 0.4676
## alternative hypothesis: two-sided
# p-value > 0.05


# (b) 독립성 검정: 런 검정
library(snpar)
runs.test(ran_seed)
##
## Approximate runs rest
##
## data: ran_seed
## Runs = 53, p-value = 0.6877
## alternative hypothesis: two.sided

# p-value > 0.05






# Q2 ------------------------------------
set.seed(10)
N = 1000 # 반복 수
p = 6
Y_sample = sample(c(0, 1), N * p, prob = c(0.8, 0.2), replace = T)
Y = matrix(Y_sample, nrow = N, ncol = p)

mean(rowSums(Y) >= 1) # 경험적 확률
## [1] 0.746

1-0.8^6 # 이론적 확률
## [1] 0.737856




# Q3 ------------------------------------

Buffon = function(n, lofneedle, distance)
{
  set.seed(2020)
  lofneedle = lofneedle / 2
  distance = distance / 2
  r1 = runif(n)
  r2 = runif(n)
  prob = mean(r1*distance < lofneedle*sin(r2*pi))
  return(prob)
}

# 경험적 확률
N = c(10, 50, 100, 1000, 5000)
est_p = unlist(lapply(N, Buffon, lofneedle = 15, distance = 20))

# 이론적 확률
theo_p = 2 * 15 / (3.14 * 20)
theo_p
## [1] 0.477707

plot(N, abs(est_p-theo_p), type = 'b')
